import java.util.regex.Pattern


/*
 *  Copyright (c) 2019 Raffael Herzog
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 */

buildscript {
    repositories {
        maven {
            url 'https://plugins.gradle.org/m2/'
        }
    }
    dependencies {
        classpath 'gradle.plugin.org.jetbrains.intellij.plugins:gradle-intellij-plugin:0.4.9'
    }
}

def versionFromGit = retrieveVersionFromGit()

buildDir = file('target')

if (rootProject.properties['localPublishing'] == 'true') {
    ext.localMvn = file("$buildDir/mvn")
} else {
    ext.localMvn = null
}

ext.jacocoVersion = '0.8.4'

allprojects {
    ext.rootReportsDir = file("$rootProject.buildDir/reports")

    apply plugin: 'idea'

    buildDir = 'target'
    group = 'ch.raffael.compose'
    version = versionFromGit

    repositories { mavenCentral() }

    if (file('src/main/java').isDirectory()) {
        apply from: "$rootProject.projectDir/java.gradle"
    }

    idea.module {
        name = buildArtifactBaseName(project)
        sourceDirs += file('out/production/classes/generated')
        testSourceDirs += file('out/test/classes/generated_tests')
    }

}

apply plugin: 'jacoco'
jacoco {
    toolVersion = jacocoVersion
}
task jacocoReport(type: JacocoReport) {
    reports {
        xml.enabled = false
        csv.enabled = false
        html.enabled = true
        html.destination = file("$rootReportsDir/jacoco-html")
    }
}

task allArtifacts(type: Copy) {
    dependsOn jacocoReport
    afterEvaluate {
        dependsOn allprojects.findAll {it.tasks.findByName('build') != null}.collect {it.tasks.getByName('build')}
    }

    destinationDir file("$buildDir/all-artifacts")

    into('jars') {
        def d = delegate
        allprojects
            .findAll {it.plugins.hasPlugin('java') && it.ext.publishToMaven == true}
            .each {d.from("$it.buildDir/libs") {include '*.jar'}}
    }
    into('reports') {
        from rootReportsDir
    }
    def idea = findProject(':tools:idea')
    if (idea) {
        into('idea-plugin') {
            from idea.file("$idea.buildDir/distributions")
        }
    }

    doLast {
        def files = { html, dir, cond ->
            def list = []
            fileTree("$destinationDir/$dir").visit {f ->
                if (cond(f)) {
                    list.add f
                }
            }
            list = list.sort()
            html.ul {
                list.each {f ->
                    li {
                        //noinspection GroovyAssignabilityCheck
                        a(href: "$dir/${f.relativePath.segments.join('/')}", f.relativePath.segments[0])
                    }
                }
            }
        }
        file("$destinationDir/index.html").withPrintWriter {out ->
            //noinspection UnnecessaryQualifiedReference
            new groovy.xml.MarkupBuilder(out).html {
                //noinspection GroovyAssignabilityCheck
                head {
                    title "Artifacts"
                }
                body {
                    h1 "Artifacts"

                    h2 'Reports'
                    files(delegate, 'reports', {it.relativePath.segments.length == 2 && it.name == 'index.html'})

                    h2 'IDEA Plugin'
                    files(delegate, 'idea-plugin', {true})

                    h2 'Jars'
                    files(delegate, 'jars', {true})
                }
            }
        }
    }
}

task allTestResults(type: Copy) {
    destinationDir file("$buildDir/all-test-results")
    afterEvaluate {
        allprojects
            .findAll {it.tasks.findByName('test') != null}
            .each { p ->
                dependsOn p.tasks.test
                from p.file("$p.buildDir/test-results")
            }
    }
}

gradle.taskGraph.whenReady { graph ->
    if (graph.allTasks.any {it instanceof Sign && it.onlyIf.isSatisfiedBy(it)}) {
        def pwd = loadEncryptedPassword(
            "signing key passphrase", rootProject.properties.'ch.raffael.compose.sign.passphrase.command')
        allprojects {
            ext.'signing.gnupg.keyName' = properties.'ch.raffael.compose.sign.keyName'
            ext.'signing.gnupg.passphrase' = pwd
        }
    }
}

String loadEncryptedPassword(String description, cmdExpr) {
    def pwdStream = new ByteArrayOutputStream()
    def cmdLine = evaluate(cmdExpr as String) as List
    logger.quiet "Retrieving $description using command: $cmdLine"
    exec {
        commandLine cmdLine
        standardOutput pwdStream
    }
     new String(pwdStream.toByteArray())
}

def buildArtifactBaseName(Project prj) {
    if (prj == rootProject) {
        return 'compose'
    } else {
        return buildArtifactBaseName(prj.parent) + '-' + ([
            ':services': 'svc'
        ].get(prj.path) ?: prj.name)
    }
}

@SuppressWarnings("unused")
def generatedOutputDir(Project prj, String generator, String srcSet) {
    return prj.file("$prj.buildDir/generated/no-ide/$generator/$srcSet")
}

@SuppressWarnings("UnnecessaryQualifiedReference")
def retrieveVersionFromGit() {
//    final noVersion = {String msg ->
//        throw new GradleException(msg)
//    }
    final noVersion = {String msg ->
        logger.warn(msg)
        return 'UNKNOWN'
    }
    Pattern releaseCandidateRE = ~'(?:rc|maintenance)/(\\d+(?:\\.\\d+)+[^/]*)'
    Pattern releaseRE = ~'release/(\\d+(\\.\\d+)+[^/]*)'
    String defaultSnapshot = 'DEVELOP'
    //---------------------------------
    def gitDir = file('.git')
    while (!gitDir.directory) {
        if (!gitDir.exists()) {
            return noVersion("$gitDir not found")
        }
        def gitDirRef = gitDir.readLines().find {it.startsWith('gitdir:')}?.substring('gitdir:'.length())?.trim()
        if (!gitDirRef) {
            throw new GradleException("$gitDir: No gitdir reference found")
        }
        gitDir = new File(gitDirRef)
        if (!gitDir.isAbsolute()) {
            throw new GradleException("$gitDir: gitdir reference is not an absolute path")
        }
    }
    def headFile = new File(gitDir, 'HEAD')
    def commonDirFile = new File(gitDir, 'commondir')
    if (commonDirFile.file) {
        gitDir = new File(gitDir, commonDirFile.text.trim())
    }
    def headRef = headFile.readLines().find {it.startsWith('ref:')}?.substring('ref:'.length())?.trim()
    if (!headRef) {
        throw new GradleException("$headFile: HEAD reference not found")
    }
    String branch = null
    if (headRef.startsWith('refs/heads/')) {
        branch = headRef.substring('refs/heads/'.length())
    } else if (headRef.startsWith('refs/tags/')) {
        branch = headRef.substring('refs/tags/'.length())
    } else if (headRef.startsWith('refs/remotes/')) {
        def remote = headRef.substring('refs/remotes/'.length())
        def pos = remote.indexOf('/')
        if (pos >= 0) {
            branch = headRef.substring(pos + 1)
        }
    }
    if (!branch) {
        throw new GradleException("$headFile: Cannot determine current branch")
    }
    logger.quiet("Determined git branch: $branch")
    def gitVersion
    def commitId = new File(gitDir, headRef.replace('/', File.separator)).text.trim()
    def tagsDir = new File(gitDir, "refs${File.separator}tags")
    def releases = []
    tagsDir.eachFileRecurse(groovy.io.FileType.FILES) {f ->
        def tag = f.toString().substring(tagsDir.toString().length() + File.separator.length()).replace(File.separator, '/')
        println "$f -> '$tag"
        def m = releaseRE.matcher(tag)
        if (m.matches() && m.group(1) != null && f.text.trim() == commitId) {
            releases.add(m.group(1))
        }
    }
    if (releases.size() > 1) {
        throw new GradleException("No distinct version tag found; candidates: $releases")
    } else if (releases.size() == 1) {
        gitVersion = releases[0]
    } else {
        def m = releaseCandidateRE.matcher(branch)
        if (m.matches() && m.group(1) != null) {
            gitVersion = "${m.group(1)}-SNAPSHOT"
        } else {
            gitVersion = "$defaultSnapshot-SNAPSHOT"
        }
    }
    logger.quiet "Version from git: $gitVersion"
    return gitVersion as String
}
